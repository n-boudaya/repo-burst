{"version":3,"file":"bundle.js","sources":["index.js"],"sourcesContent":["import * as d3 from 'd3';\r\n\r\nd3.json(\"dependencies_2024-11-11-16-18-27.json\").then(function (data) {\r\n\r\n    const svg = d3.select(\"body\").append(\"svg\").attr('width', window.innerHeight).attr('height', window.innerHeight);\r\n\r\n    svg.node().appendChild(computeMatrix(data));\r\n\r\n});\r\n\r\n// d3.csv(\"flare_depends.csv\").then(function (data) {\r\n//\r\n//     const svg = d3.select(\"body\").append(\"svg\").attr('width', window.innerHeight).attr('height', window.innerHeight);\r\n//\r\n//     svg.node().appendChild(chord_dependency(data));\r\n//\r\n// });\r\n\r\nfunction autoBox() {\r\n    document.body.appendChild(this);\r\n    const {x, y, width, height} = this.getBBox();\r\n    document.body.removeChild(this);\r\n    return [x, y, width, height];\r\n}\r\n\r\nfunction computeMatrix(data){\r\n    // console.log(data);\r\n\r\n    const names = d3.sort(data.map(d=>d.path));\r\n    // console.log(names);\r\n\r\n    const index = new Map(names.map((name, i) => [name, i]));\r\n    // console.log(index);\r\n\r\n    const matrix = Array.from(index, () => new Array(names.length).fill(0));\r\n\r\n    for(const d of data){\r\n        const source = d.path;\r\n\r\n        const onlyOutgoings = d3.map(d3.filter(d.outgoing, (d) => d.external === false), (d) => d.file);\r\n\r\n        console.log(onlyOutgoings);\r\n\r\n        for(const target of onlyOutgoings){\r\n            matrix[index.get(source)][index.get(target)] += 1;\r\n        }\r\n    }\r\n\r\n     console.log(matrix);\r\n\r\n}\r\n\r\n\r\nfunction chord_dependency(data)\r\n{\r\n    const width = 1080;\r\n    const height = width;\r\n    const innerRadius = Math.min(width, height) * 0.5 - 90;\r\n    const outerRadius = innerRadius + 10;\r\n\r\n\r\n    // // Compute a dense matrix from the weighted links in data.\r\n    // const names = d3.sort(d3.union(data.map(d => d.source), data.map(d => d.target)));\r\n    // console.log(names);\r\n    //\r\n    // const index = new Map(names.map((name, i) => [name, i]));\r\n    // console.log(index);\r\n    //\r\n    // const matrix = Array.from(index, () => new Array(names.length).fill(0));\r\n    // console.log(matrix);\r\n    // for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\r\n    // console.log(matrix);\r\n\r\n    const chord = d3.chordDirected()\r\n        .padAngle(10 / innerRadius)\r\n        .sortSubgroups(d3.descending)\r\n        .sortChords(d3.descending);\r\n\r\n    const arc = d3.arc()\r\n        .innerRadius(innerRadius)\r\n        .outerRadius(outerRadius);\r\n\r\n    const ribbon = d3.ribbonArrow()\r\n        .radius(innerRadius - 1)\r\n        // .sourceRadius(innerRadius -1)\r\n        // .headRadius(innerRadius - 1)\r\n        .padAngle(1 / innerRadius);\r\n\r\n    const colors = d3.quantize(d3.interpolateRainbow, names.length);\r\n\r\n    const svg = d3.create(\"svg\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height)\r\n        .attr(\"viewBox\", [-width / 2, -height / 2, width, height])\r\n        .attr(\"style\", \"width: 100%; height: auto; font: 10px sans-serif;\");\r\n\r\n    const chords = chord(matrix);\r\n\r\n    const group = svg.append(\"g\")\r\n        .selectAll()\r\n        .data(chords.groups)\r\n        .join(\"g\");\r\n\r\n    group.append(\"path\")\r\n        .attr(\"fill\", d => colors[d.index])\r\n        .attr(\"d\", arc);\r\n\r\n    group.append(\"text\")\r\n        .each(d => (d.angle = (d.startAngle + d.endAngle) / 2))\r\n        .attr(\"dy\", \"0.35em\")\r\n        .attr(\"transform\", d => `\r\n        rotate(${(d.angle * 180 / Math.PI - 90)})\r\n        translate(${outerRadius + 5})\r\n        ${d.angle > Math.PI ? \"rotate(180)\" : \"\"}\r\n      `)\r\n        .attr(\"text-anchor\", d => d.angle > Math.PI ? \"end\" : null)\r\n        .text(d => names[d.index]);\r\n\r\n    group.append(\"title\")\r\n        .text(d => `${names[d.index]}\r\n${d3.sum(chords, c => (c.source.index === d.index) * c.source.value)} outgoing →\r\n${d3.sum(chords, c => (c.target.index === d.index) * c.source.value)} incoming ←`);\r\n\r\n    svg.append(\"g\")\r\n        .attr(\"fill-opacity\", 0.75)\r\n        .selectAll()\r\n        .data(chords)\r\n        .join(\"path\")\r\n        .style(\"mix-blend-mode\", \"multiply\")\r\n        .attr(\"fill\", d => colors[d.target.index])\r\n        .attr(\"d\", ribbon)\r\n        .append(\"title\")\r\n        .text(d => `${names[d.source.index]} → ${names[d.target.index]} ${d.source.value}`);\r\n\r\n    console.log(svg.node());\r\n    // return svg.attr(\"viewBox\", autoBox).node();\r\n    return svg.node();\r\n}\r\n"],"names":["d3"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAEAA,iBAAE,CAAC,IAAI,CAAC,uCAAuC,CAAC,CAAC,IAAI,CAAC,UAAU,IAAI,EAAE;AACtE;IACA,IAAI,MAAM,GAAG,GAAGA,aAAE,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,WAAW,CAAC,CAAC;AACrH;IACA,IAAI,GAAG,CAAC,IAAI,EAAE,CAAC,WAAW,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC;AAChD;IACA,CAAC,CAAC,CAAC;AAgBH;IACA,SAAS,aAAa,CAAC,IAAI,CAAC;IAC5B;AACA;IACA,IAAI,MAAM,KAAK,GAAGA,aAAE,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;IAC/C;AACA;IACA,IAAI,MAAM,KAAK,GAAG,IAAI,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7D;AACA;IACA,IAAI,MAAM,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5E;IACA,IAAI,IAAI,MAAM,CAAC,IAAI,IAAI,CAAC;IACxB,QAAQ,MAAM,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC;AAC9B;IACA,QAAQ,MAAM,aAAa,GAAGA,aAAE,CAAC,GAAG,CAACA,aAAE,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,QAAQ,KAAK,KAAK,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC;AACxG;IACA,QAAQ,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;AACnC;IACA,QAAQ,IAAI,MAAM,MAAM,IAAI,aAAa,CAAC;IAC1C,YAAY,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC;IAC9D,SAAS;IACT,KAAK;AACL;IACA,KAAK,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AACzB;IACA;;;;;;"}